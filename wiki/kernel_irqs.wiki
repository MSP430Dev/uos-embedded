#summary Kernel: handling interrupts

= Прерывания =

Для обработки аппаратных прерываний применяется механизм сообщений.
При захвате ресурса задача может присвоить ему номер аппаратного
прерывания, и ожидать сообщения.
При возникновении прерывания задача получит сообщение (пустое).

После вызова `mutex_lock_irq()` аппаратное прерывание считается
связанным с указанным ресурсом.
Для каждого аппаратного прерывания, требующего обслуживания,
следует создать отдельную задачу. Такая задача обычно
в бесконечном цикле ожидает сообщения о прерывании, выполняет
необходимые действия с аппаратурой и посылает сообщения другим
ресурсам, содержащие результаты обработки.

Такой метод обработки прерываний обладает простотой и наглядностью,
но имеет один недостаток: он требует переключения задач на каждое
прерывание.  Для тех случаев, когда нужна более быстрая реакция
на прерывания, применяется дополнительный механизм _*быстрой обработки*_.

Быстрый обработчик представляет собой функцию, которая регистрируется
при захвате ресурса прерывания, и вызывается ядром при наступлении прерывания,
обеспечивая максимально высокую скорость реакции. Обслужив прерывание,
быстрый обработчик принимает решение и возвращает ядру признак:
следует ли посылать основной задаче-обработчику сообщение о прерывании.
Таким образом, работа по обработке разделяется между основной задачей
прерывания и быстрым обработчиком: срочные действия выполняет
быстрый обработчик, а "медленные" - основная задача.

Пока ресурс захвачен функцией `mutex_lock()`,
быстрый обработчик не может быть вызван "немедленно",
так как это привело бы к конфликту совместного доступа к данным.
В этом случае вызов быстрого обработчика откладывается до освобождения ресурса
функциями `mutex_unlock()` или `mutex_wait()`.

Поскольку быстрый обработчик выполняется в обход механизма
синхронизации задач, на него накладываются некоторые ограничения.
Во избежание конфликта с другими задачами, он имеет право работать
только с данными, защищенными ресурсом прерывания.
Он не должен вызывать никакие функции ядра
(`task_xxx()`, `mutex_xxx()`) ни непосредственно, ни
посредством вызова других модулей. В частности, он не может
обращаться к модулю управления памятью (`mem_alloc()` и пр.).
Подобные действия должны перекладываться на задачу-обработчик.

При возникновении прерывания выполняются следующие действия:
 # Аппаратный запрет прерывания (закрывается маска в контроллере прерываний).
 # При наличии быстрого обработчика:
   # Если ресурс занят - вызов быстрого обработчика откладывается до освобождения ресурса. Обработка прерывания закончена.
   # Вызов быстрого обработчика. Если обработчик вернул ненулевой код - обработка прерывания закончена.
 # Посылка сообщения ресурсу.
 # Переключение задач.

Аппаратное разрешение прерывания (открытие маски в контроллере прерываний)
производится при вызове функции `mutex_wait()`.

{{{
#include "kernel/uos.h"

typedef int (*handler_t) (void*);

void mutex_lock_irq (mutex_t *lock, int irq, handler_t func, void *arg);
void mutex_unlock_irq (mutex_t *lock);
}}}

Для работы с прерываниями применяются следующие функции:
|| *Функция*            || *Описание* ||
|| mutex_lock_irq ()	|| Захват прерывания ||
|| mutex_unlock_irq ()	|| Освобождение прерывания ||
|| mutex_wait ()		|| Ожидание прерывания ||

== Функция mutex_lock_irq() ==
{{{
#include "kernel/uos.h"

void mutex_lock_irq (mutex_t *lock, int irq, handler_t func, void *arg);
}}}

Захват ресурса и привязка его к аппаратному прерыванию с указанным номером.
Если ресурс свободен, переключение задач не происходит.
Если ресурс занят другой задачей, текущая задача блокируется
до освобождения ресурса.

После вызова `mutex_lock_irq()` аппаратное прерывание считается
связанным с указанным ресурсом.
При возникновении прерываний будет вызван быстрый обработчик,
а ресурс будет получать сообщение.
При последующих захватах ресурса функцией `mutex_lock()`
вызов быстрого обработчика откладывается на время удержания ресурса.
Отложенное прерывание будет обработано при освобождении ресурса
вызовом `mutex_unlock()`, или `mutex_wait()`.

Для каждого аппаратного прерывания, требующего обслуживания,
следует создать отдельную задачу. Такая задача должна работать по следующему
алгоритму:
 # захватить прерывание вызовом `mutex_lock_irq()`
 # инициализировать обслуживаемую аппаратуру
 # в цикле ожидать прерывания вызовом `mutex_wait()`
 # выполнить необходимые действия с аппаратурой, сохранить данные и т.п.
 # при необходимости послать сообщения другим ресурсам вызовом `mutex_signal()`
 # перейти к п.3, продолжив цикл ожидания прерывания

=== Параметры ===
 * `lock` --- Ресурс, который требуется захватить.
 * `irq`  --- Номер аппаратного прерывания, который будет привязан к данному ресурсу.
 * `func` --- Указатель на функцию -- быстрый обработчик прерывания (see section [[#2.4.3 Тип handler_t]]). Необязательный параметр. Если нет необходимости использовать быстрый обработчик, следует указать параметр `func` равным `0`.
 * `arg` --- Аргумент, передаваемый быстрому обработчику прерывания (see section [[#2.4.3 Тип handler_t]]).

[http://uos-embedded.googlecode.com/svn/wiki/images/itake.png]

=== Пример ===
{{{
TODO example mutex_lock_irq.c
}}}

== Функция mutex_unlock_irq() ==
{{{
#include "kernel/uos.h"

void mutex_unlock_irq (mutex_t *lock);
}}}

Освобождение ресурса, отмена привязки аппаратного прерывания.
Прерывание блокируется (запрещается).
Может произойти переключение задач.

Следует заметить, что функция `mutex_unlock()` не отменяет
привязку и не блокирует прерывание.

=== Параметры ===
 * `lock` --- Ресурс, который требуется освободить.

[http://uos-embedded.googlecode.com/svn/wiki/images/irelease.png]

=== Пример ===
{{{
TODO example mutex_lock_irq.c
}}}

== Тип handler_t ==
{{{
#include "kernel/uos.h"

typedef int (*handler_t) (void *arg);
}}}

Тип -- указатель на функцию быстрой обработки прерываний.

Стандартный метод обработки прерываний
требует переключения задач на каждое прерывание.
Для тех случаев, когда нужна более быстрая реакция на прерывания,
применяется дополнительный механизм быстрой обработки.

Быстрый обработчик представляет собой функцию, которая регистрируется
при захвате ресурса прерывания, и вызывается ядром при наступлении прерывания,
обеспечивая максимально высокую скорость реакции. Обслужив прерывание,
быстрый обработчик принимает решение и возвращает ядру признак:
следует ли посылать основной задаче-обработчику сообщение о прерывании.
Таким образом, работа по обработке разделяется между основной задачей
прерывания и быстрым обработчиком: срочные действия выполняет
быстрый обработчик, а "медленные" - основная задача.

Поскольку быстрый обработчик выполняется в обход механизма
синхронизации задач, на него накладываются некоторые ограничения.
Во избежание конфликта с другими задачами, он имеет право работать
только с данными, защищенными ресурсом прерывания.
Он не должен вызывать никакие функции ядра
(`task_xxx()`, `mutex_xxx()`) ни непосредственно, ни
посредством вызова других модулей. В частности, он не может
обращаться к модулю управления памятью (`mem_alloc()`и пр.).
Подобные действия должны перекладываться на задачу-обработчик.

=== Параметры ===
 * `arg` --- Аргумент, передаваемый быстрому обработчику прерывания. Задается при захвате прерывания функцией `mutex_lock_irq()` (see section [[#2.4.1 Функция mutex_lock_irq()]]).

=== Пример ===
{{{
TODO example handler.c
}}}
