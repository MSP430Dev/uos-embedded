#summary Success story: porting uOS to Elvees Multicore MIPS32 architecture

= Микроконтроллеры Элвис Мультикор =
Описана последовательность работ по переносу системы uOS на архитектуру [http://www.mips.com/products/processors/architectures/mips32/ MIPS32],
применительно к микроконтроллеру [http://multicore.ru/index.php?id=47 MC-24] семейства Элвис Мультикор.

Скалярное ядро процессоров Элвис Мультикор имеет архитектуру MIPS32,
которая пока не поддерживается операционной системой uOS.
В первую очередь требуется реализация машинно-зависимой части микроядра для архитектуры
MIPS32. Затем необходимо реализовать работу с периферийными устройствами:
инициализацию, таймер, UART и т.д.

=== 1. Создаём каталог целевой платформы ===
Создаем каталог uos/targets/mc24. Помещаем туда файлы, необходимые для компиляции.
{{{
mkdir uos/targets/mc24
cd uos/targets/mc24
cp ../s3c4530/Makefile .
cp ../s3c4530/target.cfg .
cp ../s3c4530/ldscript.x .
}}}

В файле [http://code.google.com/p/uos-embedded/source/browse/trunk/targets/mc24/target.cfg target.cfg] изменяем значения переменных:
  * ARCH - mips32.
  * MODULES - необходимо убрать s3c4530.
  * CFLAGS - задаем тип платформы -DMIPS32 и модель конкретного микроконтроллера -DELVEES_MC24.
  * BINDIR - устанавливаем правильный путь к компилятору, в моём случае это /usr/local/mipsel432/bin.
  * CC, AR и прочие - устанавливаем имена компонентов компилятора: mipsel-elf32-gcc и т.п.
  * STARTUP - стартовый код разместим в файле startup-mc24.S.

В файле [http://code.google.com/p/uos-embedded/source/browse/trunk/targets/mc24/ldscript.x ldscript.x] заменяем везде arm на mips,
а также в блоке MEMORY изменяем адреса и длины сегментов памяти:
  * Для text устанавливаем ORIGIN = 0xbfc00000, LENGTH = 2M
  * Для data устанавливаем ORIGIN = 0xb8000000, LENGTH = 32K

В сегменте .data после __data_start добавляем установку адреса для регистра $gp.
Поскольку в контроллере МС-24 имеется всего 32 килобайта внутренней памяти,
смещение на 0x8000 не требуется:
{{{
_gp = .;
}}}

=== 2. Создаём файл описания специальных регистров процессора ===

Создаём каталог uos/sources/runtime/mips32 и в нём include-файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/mips32/io.h io.h] с описанием регистров платформы MIPS32. Для конкретного процессора МС-24 делаем отдельный файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/mips32/io-mc24.h io-mc24.h]. Файл io.h имеет вид:
{{{
#ifdef ELVEES_MC24
#   include <runtime/mips32/io-mc24.h>
#endif
}}}
В дальнейшем сюда можно добавлять варианты для других процессоров с архитектурой MIPS32.

В файл io.h также помещаем определения inline-функций для доступа к аппаратным регистрам:
  * `int mips32_get_stack_pointer ()` - чтение значения регистра стека SP
  * `void mips32_set_stack_pointer (int)` - установка значения регистра стека SP
  * `int mips32_read_c0_register (int)` - чтение регистров сопроцессора C0
  * `void mips32_write_c0_register (int, int)` - запись регистров сопроцессора C0
  * `void mips32_intr_disable (int *)` - сохранение статуса и запрет прерываний
  * `void mips32_intr_restore (int)` - восстановление статуса прерываний
  * `void mips32_intr_enable ()` - разрешение прерываний

=== 3. Проектируем структуру контекста ===

Определяем количество и порядок регистров, сохраняемых в стеке при входе в прерывание или исключение. [arch_mips_notes Документируем] на будущее.

=== 4. Создаём стартовый файл ===

Создаём стартовый файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/mips32/startup-mc24.S startup-mc24.S]. Стартовый код размещаем в секции .init, которая будет находиться по адресу 0xbfc00000. Вектора прерываний:
  * bfc00000 - аппаратный сброс, немаскируемое прерывание. Вызов Си-функции `_init_()`.
  * bfc00200 - обращение к отсутствующей странице. Сохранение регистров в стеке и вызов Си-функции `_pagefault_handler_(context)`.
  * bfc00380 - исключение. Сохранение регистров в стеке и вызов Си-функции `_exception_handler_(context)`.
  * bfc00400 - прерывание. Сохранение регистров в стеке и вызов Си-функции `_interrupt_handler_(context)`.
Здесь `int *context` указывает на массив из 32-х сохранённых регистров.

=== 5. Делаем функцию начальной инициализации ===
Создаём файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/mips32/init.c uos/sources/runtime/mips32/init.c], содержащий функцию `_init_()`. Она должна:
  * устанавливать начальное состояние регистров микроконтроллера;
  * копировать инициализированные данные из памяти Flash в ОЗУ;
  * обнулять сегмент BSS;
  * вызывать функцию `main()`.
Как образец можно использовать аналогичный файл для архитектуры ARM: [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/arm/init.c runtime/arm/init.c].

=== 5. Создаём обработчики исключений ===
В файл init.c добавляем функции `_pagefault_handler_(context)` и `_exception_handler_(context)`. Они должны печатать на отладочную консоль значения регистров и выполнять аппаратный сброс системы.

=== 6. Делаем функции отладочной выдачи на консоль ===
В файле [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/mips32/debug.c uos/sources/runtime/mips32/debug.c] создаём функции отладочной
выдачи на консоль: `debug_putchar()`, `debug_getchar()`, `debug_peekchar()`. Заключаем их в #ifdef ELVEES_MC24 ... #endif.

... TODO ...

=== 5. Добавляем обработку прерываний ===
В файле uos/sources/kernel/arm/machdep.c в функциях `_irq_handler_()` и
`arm_intr_allow()` добавляем работу с регистрами контроллера прерываний.
Заключаем его в #ifdef ARM_AT91SAM ... #endif.

=== 6. Обрабатываем таймер ===
В файле uos/sources/timer/timer.c добавляем инициализацию регистров таймера.