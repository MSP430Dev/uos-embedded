#summary uOS coding style, draft

= Стиль кодирования =
Этот документ описывает стиль кодирования, принятый в проекте uOS.
Пожалуйста, старайтесь следовать этим рекомендациям, чтобы
поддерживать качество кода.

**Помните!** Код чаще приходится читать, чем писать, поэтому
понятность и чистота кода гораздо важнее скорости набора.

== Идентификаторы ==
Выбирайте имена, которые ясно и четко описывают предназначение и/или смысл
сущности. Старайтесь не использовать сокращения лишний раз, помните о тех,
кто читает код.

Используйте подчеркивание для отделения слов внутри идентификаторов,
это существенно облегчает чтение.

Не используйте малопонятные префиксы или суффиксы (например,
венгерскую нотацию).

Используйте 0 вместо NULL.

Правильно:
{{{
void function (char *my_string)
}}}
Неправильно:
{{{
void function (char *myArgument)

void function (char *lpstrArgument)
}}}

=== Переменные ===
Имена переменных и полей структур должны состоять из строчных букв.
Если имя состоит из нескольких слов, они должны разделяться подчеркиванием,
как "red_push_button".
Не используйте суффиксы или префиксы "`_`", "`m_`" и подобные.

Локальные имена переменных лучше делать короткими.

=== Константы ===
Для констант применяйте имена из заглавных букв. Слова разделяйте
подчеркиванием, например "MAX_CHILDREN".

=== Функции и методы ===
Имена функций языка Си состоят из строчных букв (стиль GNU). Слова разделяются подчеркиванием, например "task_create".

В именах методов Си++ первая буква слова должны быть заглавная, остальные - строчные (стиль Ada). Слова разделяются подчеркиванием, например "Create_Top_Window".

=== Типы, классы и интерфейсы ===
Имена типов, классов и интерфейсов создаются аналогично функциям, но с добавлением суффикса "_t":
{{{
typedef unsigned long address_t;
}}}

== Отступы ==
Используйте 8-символьную табуляцию, а не пробелы для отступов.
Если правите чужой код - старайтесь придерживаться авторского стиля.

Избегайте строк длиннее 78 символов, переносите инструкцию на другую
строку при необходимости. При переносе части кода на другую строку вторая
последующая строки должны быть отбиты вправо на один отступ (табуляцию).

Не размещайте несколько инструкций на одной строке.
Каждая инструкция должна начинаться с новой строки.

Для уменьшения уровня вложенности кода используйте операторы
continue или break. Например, вместо:
{{{
for (i = 0; i < 10; i++) {
	if (something (i)) {
		do_more ();
	}
}
}}}
лучше сделать так:
{{{
for (i = 0; i < 10; i++) {
	if (! something (i))
		continue;
	do_more ();
}
}}}

Метки оператора switch размещайте на том же уровне:
{{{
switch (x) {
case 'a':
	...
case 'b':
	...
}
}}}

== Пробелы ==
Ставьте пробел перед открывающей скобкой при вызове функции или
индексировании массива, например:
{{{
function (a);
b [10];
}}}

Не ставьте пробел после открывающей или перед закрывающей скобкой. Правильно:
{{{
function (a);	array [10];
}}}
Неправильно:
{{{
function ( a );	array[ 10 ];
}}}

В операторах ставьте открывающую фигурную скобку на той же строке.
Правильно:
{{{
if (a) {
	Code ();
	Code ();
}
}}}
Неправильно:
{{{
if (a)
{
	Code ();
	Code ();
}
}}}

При объявлении функции располагайте фигурные скобки с новой строки.
Правильно:
{{{
void function ()
{
}
}}}
Неправильно:
{{{
void function () {
}
}}}

Не экономьте пробелы в выражениях.
Правильно:
{{{
if (a + 5 > function (blah () + 4))
}}}
Неправильно:
{{{
if (a+5>function(blah()+4))
}}}

== Файлы ==
Во всех файлах вначале делайте краткое описание.
Добавляйте ссылку на лицензию. Например:
{{{
/*
 * Handle comments in System files.
 *
 * Author: Juan Perez (juan@address.com)
 * Copyright (C) 2002 Address, Inc
 *
 * This file is distributed ...
 * ... license ...
 */
}}}

Если Вы изменяете чужой код и вносите существенный вклад,
пожалуйста добавьте себя к списку авторов.

=== Имена файлов ===
Файлы должны иметь следующие расширения:
|| *Язык*              || *Расширение* ||
|| Заголовки Си, Си++  ||  .h          ||
|| Код Cи              ||  .с          ||
|| Код Си++            ||  .сpp        ||
|| Заголовки Ada       ||  .ads        ||
|| Код Ada             ||  .adb        ||

Имена файлов Си, а также каталогов, должны состоять из строчных букв.
Имена файлов Си++ и Ada должны начинаться
с заглавной буквы (стиль Ada).

=== Файлы заголовков ===
Файлы заголовков Си должны содержать защитное обрамление:
{{{
#ifndef MODULE_CLASSNAME_H
#define MODULE_CLASSNAME_H
#ifdef __cplusplus
extern "C" {
#endif

...

#ifdef __cplusplus
}
#endif
#endif
}}}

Файлы заголовков Си++ должны включаться в код с помощью конструкции
"#import", поэтому для них защитное обрамление не требуется.

== Базовые целочисленные типы ==

В файле runtime/lib.h определён ряд целочисленных типов данных.
Основное их предназначение - помощь програмисту в создании переносимых программ.

=== Целые типы фиксированного размера ===
Размер этих типов жестко задан и не зависит от архитектуры целевого процессора.
Их рекомендуется использовать в структурах данных, а также при вычислениях,
если результат зависит от количества разрядов.

 * int8_t -- 8 бит, со знаком
 * uint8_t -- 8 бит, без знака
 * int16_t -- 16 бит, со знаком
 * uint16_t -- 16 бит, без знака
 * int32_t -- 32 бит, со знаком
 * uint32_t -- 32 бит, без знака
 * int64_t -- 64 бит, со знаком
 * uint64_t -- 64 бит, без знака

Типы int8_t, uint8_t, int16_t и uint16_t не очень актуальны, так как вместо них
можно использовать стандартные signed char, unsigned char, signed short и
unsigned short соответственно.

=== Целые типы нежесткого размера ===
На некоторых RISC-архитектурах (например ARM и MIPS) работа со однобайтными или
двухбайтными значениями требует большего количества машинных инструкций,
чем для типа int. При простой обработке, например для счетчика цикла,
рекоментуется применять следующие типы. Они задают наиболее оптимальные
для целевого процессора значения, имеющие нужное число разрядов (или больше).

Эти типы рекомендуется применять в случаях, когда точный размер целого
числа не имеет большого значения.

 * small_int_t -- не менее 8 бит, со знаком
 * small_uint_t -- не менее 8 бит, без знака
 * bool_t -- достаточный для хранения значений 0 и 1, со знаком

Тип bool_t идентичен small_int_t, но предназначен для случаев, где используется логическое значение TRUE(1) или FALSE(0).

Если требуется целочисленный тип, обеспечивающий не менее 16 бит, следует использовать
обычный int или unsigned int.

Если требуется тип, обеспечивающий не менее 32 бит, следует использовать
int32_t или uint32_t.

=== Сравнение для разных архитектур ===
|| *Тип*        || *AVR*              || *MSP430*           || *ARM, MIPS, i386*   || *ia64*         ||
|| int8_t       || signed char        || signed char        || signed char         || signed char    ||
|| uint8_t      || unsigned char      || unsigned char      || unsigned char       || unsigned char  ||
|| int16_t      || int                || int                || short               || short          ||
|| uint16_t     || unsigned int       || unsigned int       || unsigned short      || unsigned short ||
|| int32_t      || long               || long               || int                 || int            ||
|| uint32_t     || unsigned long      || unsigned long      || unsigned int        || unsigned int   ||
|| int64_t      || long long          || long long          || long long           || long           ||
|| uint64_t     || unsigned long long || unsigned long long || unsigned long long  || unsigned long  ||
|| small_int_t  || signed char        || int                || int                 || int            ||
|| small_uint_t || unsigned char      || unsigned int       || unsigned int        || unsigned int   ||
|| bool_t       || signed char        || int                || int                 || int            ||
