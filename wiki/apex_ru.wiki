#summary APEX - system calls for ARINC 653 (Russian).

APEX представляет собой набор сервисов (системных вызовов) стандарта ARIC 653.

= 1. Категории сервисов =

    * Вызовы APEX сгруппированы в следующие категории:
    * Управление разделами
    * Управление процессами
    * Управление временем
    * Управление памятью
    * Взаимодействие между разделами
    * Взаимодействие внутри раздела
    * Мониторинг состояний

=== RETURN_CODE_TYPE - код возврата ===
Все вызовы возвращают код результата выполнения RETURN_CODE_TYPE:
{{{
typedef enum {
        NO_ERROR        = 0,
        NO_ACTION       = 1,
        NOT_AVAILABLE   = 2,
        INVALID_PARAM   = 3,
        INVALID_CONFIG  = 4,
        INVALID_MODE    = 5,
        TIMED_OUT       = 6
} RETURN_CODE_TYPE;
}}}

|| NO_ERROR        || Корректный запрос, действие выполнено ||
|| NO_ACTION       || Запрос не повлиял на состояние системы ||
|| NOT_AVAILABLE   || Запрашиваемый ресурс недоступен ||
|| INVALID_PARAM   || Неверный параметр запроса ||
|| INVALID_CONFIG  || Параметр несовместим с конфигурацией ||
|| INVALID_MODE    || Параметр несовместим с текущим режимом ||
|| TIMED_OUT       || Запрос прерван по истечению временного интервала ||

= 2. Управление разделами =
Вызовы:
    * GET_PARTITION_STATUS
    * SET_PARTITION_MODE

Типы:
{{{
typedef enum {
    IDLE        = 0,
    COLD_START    = 1,
    WARM_START    = 2,
    NORMAL        = 3
} OPERATING_MODE_TYPE;

typedef long        PARTITION_ID_TYPE;
typedef long        LOCK_LEVEL_TYPE;
typedef long long    SYSTEM_TIME_TYPE;

typedef struct {
    PARTITION_ID_TYPE    IDENTIFIER;
    SYSTEM_TIME_TYPE    PERIOD;
    SYSTEM_TIME_TYPE    DURATION;
    LOCK_LEVEL_TYPE        LOCK_LEVEL;
    OPERATING_MODE_TYPE    OPERATING_MODE;
} PARTITION_STATUS_TYPE;
}}}

=== GET_PARTITION_STATUS - запрос состояния раздела ===
{{{
void GET_PARTITION_STATUS (
    /*out*/ PARTITION_STATUS_TYPE    *PARTITION_STATUS,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );
}}}
Запрашивает статус текущего раздела.

Код возврата: NO_ERROR.

=== SET_PARTITION_MODE - установка режима раздела ===
{{{
void SET_PARTITION_MODE (
    /*in */ OPERATING_MODE_TYPE    OPERATING_MODE,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );
}}}
Если OPERATING_MODE содержит некорректный режим: возвращает INVALID_PARAM.
Иначе если OPERATING_MODE равно NORMAL и текущий режим NORMAL: возвращает NO_ACTION.
Иначе устанавливает режим раздела:

    * если OPERATING_MODE равно IDLE --- останавливает раздел.
    * если OPERATING_MODE равно WARM_START или COLD_START --- прекращает переключение процессов и возвращается в режим инициализации.
    * если OPERATING_MODE равно NORMAL --- вычисляет DEADLINE_TIME всех активных процессов раздела; запускает переключение процессов.

3. Управление процессами
Вызовы:
    * GET_PROCESS_ID
    * GET_PROCESS_STATUS
    * CREATE_PROCESS
    * SET_PRIORITY
    * SUSPEND_SELF
    * SUSPEND
    * RESUME
    * STOP_SELF
    * STOP
    * START
    * LOCK_PREEMPTION
    * UNLOCK_PREEMPTION

Типы:
{{{
typedef long        PROCESS_ID_TYPE;
typedef char        PROCESS_NAME_TYPE [30];
typedef long        PRIORITY_TYPE;
typedef unsigned long    STACK_SIZE_TYPE;
typedef long        LOCK_LEVEL_TYPE;
typedef void *        SYSTEM_ADDRESS_TYPE;
typedef long long    SYSTEM_TIME_TYPE;

typedef enum {
    DORMANT    = 0,
    READY    = 1,
    RUNNING    = 2,
    WAITING    = 3
} PROCESS_STATE_TYPE;

typedef enum { SOFT = 0, HARD = 1 } DEADLINE_TYPE;

typedef struct {
    PROCESS_NAME_TYPE    NAME;
    SYSTEM_ADDRESS_TYPE    ENTRY_POINT;
    STACK_SIZE_TYPE        STACK_SIZE;
    PRIORITY_TYPE        BASE_PRIORITY;
    SYSTEM_TIME_TYPE    PERIOD;
    SYSTEM_TIME_TYPE    TIME_CAPACITY;
    DEADLINE_TYPE        DEADLINE;
} PROCESS_ATTRIBUTE_TYPE;

typedef struct {
    PROCESS_ATTRIBUTE_TYPE    ATTRIBUTES;
    PRIORITY_TYPE        CURRENT_PRIORITY;
    SYSTEM_TIME_TYPE    DEADLINE_TIME;
    PROCESS_STATE_TYPE    PROCESS_STATE;
} PROCESS_STATUS_TYPE;

extern void GET_PROCESS_ID (
    /*in */ PROCESS_NAME_TYPE    PROCESS_NAME,
    /*out*/ PROCESS_ID_TYPE        *PROCESS_ID,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void GET_PROCESS_STATUS (
    /*in */ PROCESS_ID_TYPE        PROCESS_ID,
    /*out*/ PROCESS_STATUS_TYPE    *PROCESS_STATUS,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void CREATE_PROCESS (
    /*in */ PROCESS_ATTRIBUTE_TYPE    *ATTRIBUTES,
    /*out*/ PROCESS_ID_TYPE        *PROCESS_ID,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void SET_PRIORITY (
    /*in */ PROCESS_ID_TYPE        PROCESS_ID,
    /*in */ PRIORITY_TYPE        PRIORITY,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void SUSPEND_SELF (
    /*in */ SYSTEM_TIME_TYPE    TIME_OUT,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void SUSPEND (
    /*in */ PROCESS_ID_TYPE        PROCESS_ID,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void RESUME (
    /*in */ PROCESS_ID_TYPE        PROCESS_ID,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void STOP_SELF ();

extern void STOP (
    /*in */ PROCESS_ID_TYPE        PROCESS_ID,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void START (
    /*in */ PROCESS_ID_TYPE        PROCESS_ID,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void DELAYED_START (
    /*in */ PROCESS_ID_TYPE        PROCESS_ID,
    /*in */ SYSTEM_TIME_TYPE    DELAY_TIME,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void LOCK_PREEMPTION (
    /*out*/ LOCK_LEVEL_TYPE        *LOCK_LEVEL,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void UNLOCK_PREEMPTION (
    /*out*/ LOCK_LEVEL_TYPE        *LOCK_LEVEL,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );

extern void GET_MY_ID (
    /*out*/ PROCESS_ID_TYPE        *PROCESS_ID,
    /*out*/ RETURN_CODE_TYPE    *RETURN_CODE );
}}}
