#summary Success story: porting uOS to MSP430 architecture

= Микроконтроллеры MSP430 =
Описана последовательность работ по переносу системы uOS на архитектуру [http://focus.ti.com/paramsearch/docs/parametricsearch.tsp?familyId=342&sectionId=95&tabId=1200&family=mcu MSP430],
применительно к микроконтроллеру [http://focus.ti.com/docs/prod/folders/print/msp430f149.html MSP430F149].

MSP430 представляет собой 16-битную архитектуру, новую для uOS.
В первую очередь требуется реализация машинно-зависимой части микроядра для архитектуры
MSP430. Затем необходимо реализовать работу с периферийными устройствами:
инициализацию, таймер, UART и т.д.

Полезные ссылки:
  * [http://ru.wikipedia.org/wiki/MSP430 Статья в Википедии]
  * [http://www.gaw.ru/html.cgi/txt/doc/micros/msp430/index.htm Русскоязычная документация]

=== 1. Создаём каталог целевой платформы ===
Создаем каталог uos/examples/msp430-f149. Помещаем туда файлы, необходимые для компиляции.
{{{
mkdir uos/examples/msp430-f149
cd uos/examples/msp430-f149
cp ../arm-s3c4530/target.cfg .
}}}

В файле [http://code.google.com/p/uos-embedded/source/browse/trunk/examples/msp430-f149/target.cfg target.cfg] изменяем значения переменных:
  * ARCH - msp430.
  * MODULES - необходимо убрать s3c4530.
  * CFLAGS - задаем тип платформы -DMSP430.
  * BINDIR - устанавливаем правильный путь к компилятору, в моём случае это /usr/local/msp323/bin.
  * CC, AR и прочие - устанавливаем имена компонентов компилятора: msp430-gcc и т.п.
  * STARTUP - стартовый код разместим в файле startup.S.

В качестве скрипта линкера используем /usr/local/msp323/msp430/lib/ldscripts/msp430x147.x.

=== 2. Создаём файл описания специальных регистров процессора ===
Создаём каталог uos/sources/runtime/msp430. Помещаем в него файлы io.h, iomacros.h, msp430x14x.h, и прочие из проекта [http://mspgcc.cvs.sourceforge.net/viewvc/mspgcc/msp430-libc/include/ MSPGCC] с описанием регистров платформы MSP430.

В файл iomacros.h помещаем определения inline-функций для доступа к аппаратным регистрам. Там уже имеются макросы READ_SR, WRITE_SR(), READ_SP и WRITE_SP. Переделываем их следующим образом:
  * `int msp430_get_stack_pointer ()` - чтение значения регистра стека SP
  * `void msp430_set_stack_pointer (int)` - установка значения регистра стека SP
  * `void msp430_intr_disable (int *)` - сохранение статуса и запрет прерываний
  * `void msp430_intr_restore (int)` - восстановление статуса прерываний
  * `void msp430_intr_enable ()` - разрешение прерываний

=== 3. Создаём стартовый файл ===
На основе [http://mspgcc.cvs.sourceforge.net/viewvc/mspgcc/msp430-libc/src/gcrt0.S gcrt0.S из проекта MSPGCC] создаём стартовый файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/msp430/startup.S startup.S].

=== 4. Делаем функцию начальной инициализации ===
Создаём файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/msp430/init.c uos/sources/runtime/msp430/init.c], содержащий функцию `_init_()`. Она должна:
  * устанавливать начальное состояние регистров микроконтроллера;
  * копировать инициализированные данные из памяти Flash в ОЗУ;
  * обнулять сегмент BSS;
  * вызывать функцию `main()`.
Как образец можно использовать аналогичный файл для архитектуры ARM: [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/arm/init.c runtime/arm/init.c].

=== 5. Создаем архитектурозависимые файлы стандартной библиотеки ===
Создаём файлы [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/msp430/types.h sources/runtime/msp430/types.h], [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/msp430/stdlib.h sources/runtime/msp430/stdlib.h] и [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/msp430/string.h sources/runtime/msp430/string.h]:
{{{
cd uos/sources/runtime/msp430/
cp ../arm/types.h ../arm/stdlib.h ../arm/string.h .
}}}
В начале файла [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/arch.h sources/runtime/arch.h] в соответствующее место добавляем фрагмент:
{{{
#elif defined (MSP430)
#       include <stdarg.h>
#       include <runtime/msp430/types.h>
#       include <runtime/msp430/string.h>
#       include <runtime/msp430/stdlib.h>
#       include <runtime/msp430/io.h>
#       include <runtime/ctype.h>
#       define __BYTE_ORDER __LITTLE_ENDIAN
#       define __FLOAT_WORD_ORDER __LITTLE_ENDIAN
}}}
Теперь можно проверить, что файл init.c правильно компилируется:
{{{
/usr/local/msp323/bin/msp430-gcc -c -fno-builtin -DMSP430 -I../.. init.c
}}}

=== 6. Делаем функции отладочной выдачи на консоль ===
В файле [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/runtime/msp430/debug.c uos/sources/runtime/msp430/debug.c] создаём функции отладочной
выдачи на консоль: `debug_putchar()`, `debug_getchar()`, `debug_peekchar()`.

=== 7. Первый тест: отладочная выдача на консоль ===
В каталоге uos/examples/msp430-f149 создаём файлы test_debug.c:
{{{
#include <runtime/lib.h>

int main (void)
{
        for (;;) {
                debug_printf ("Hello, World!\n");
                debug_getchar();
        }
}
}}}
и Makefile:
{{{
TARGET          = $(CURDIR)
OS              = $(shell cd ../..; pwd)
include target.cfg

TESTS           = test_debug.sre

all:            $(TESTS)
                for f in *.out; do $(SIZE) $$f; done
clean:
                rm -rf *~ *.[oasi] *.out *.srec *.lst *.dis .deps $(MODULES) $(TESTS)

include $(OS)/sources/rules.mak
}}}
Запускаем "make". В результате получаем файл `test_debug.sre`, который загружаем в ПЗУ целевой платы. При включении на консоль должна выдаваться строка "Hello, World" (скорость 115200, 8 бит, без чётности).

=== 8. Проектируем структуру контекста ===
Определяем количество и порядок регистров, сохраняемых в стеке при входе в прерывание или исключение. [arch_msp430_notes Документируем] на будущее.

=== 9. Создаём обработчики исключений ===
В файл init.c добавляем функции `_pagefault_handler_(context)` и `_exception_handler_(context)`. Они должны печатать на отладочную консоль значения регистров и выполнять аппаратный сброс системы.

=== 10. Перенос ядра ===
Создаём каталог uos/sources/kernel/msp430 и в нём include-файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/kernel/msp430/machdep.h machdep.h] с описанием машинно-зависимых функций и макросов для платформы MSP430:
  * `ARCH_INTERRUPTS` - количество аппаратный прерываний, 40 для MC-24
  * `arch_state_t` - тип для хранения маски аппаратных прерываний, `int` для MIPS-32
  * `arch_stack_t` - тип для хранения указателя стека, `void *` для MIPS-32
  * `arch_get_stack_pointer ()` - inline-функция, возвращающая текущий указатель стека
  * `arch_set_stack_pointer ()` - inline-функция, устанавливающая указатель стека
  * `arch_intr_disable ()` - inline-функция, запрещающая аппаратные прерывания
  * `arch_intr_restore ()` - inline-функция, восстанавливающая режим аппаратных прерываний
  * `arch_intr_bind ()` - inline-функция, пустая для MIPS-32
  * `arch_intr_unbind ()` - inline-функция, пустая для MIPS-32
  * `arch_idle ()` - inline-функция, переводящая процессор в режим ожидания

В файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/kernel/msp430/machdep.c machdep.c] помещаем код машинно-зависимых функций:
  * `arch_task_switch ()` - функция, переключающая выполнение на другую задачу
  * `_interrupt_handler_ ()` - обработчик аппаратного прерывания, вызываемый из startup-кода
  * `arch_intr_allow ()` - функция, открывающая маску указанного аппаратного прерывания
  * `arch_build_stack_frame ()` - функция, создающая фрейм в стеке для старта новой задачи

=== 11. Второй тест: формирование задач ===
В каталоге uos/examples/msp430-f149 создаём файл test_task.c:
{{{
#include <runtime/lib.h>
#include "kernel/uos.h"

ARRAY (task, 0x400);

void hello (void *arg)
{
        for (;;) {
                debug_printf ("Hello from `%s'!\n", arg);
                debug_printf ("Task space %d bytes, free %d bytes\n",
                        sizeof (task), task_stack_avail ((task_t*) task));
                debug_printf ("(Press Enter)\n");
                debug_getchar ();
        }
}

void uos_init (void)
{
        debug_puts ("\nTesting task.\n");
        task_create (hello, "task", "hello", 1, task, sizeof (task));
}
}}}
В файле Makefile устанавливаем `TESTS = test_task.sre`.
Запускаем "make". В результате получаем файл `test_task.sre`, который загружаем в ПЗУ целевой платы. При включении на консоль должна выдаваться строка "Hello from `task'" и информация о свободной части стека задачи.

=== 12. Драйвер таймера ===
В начале файла [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/timer/timer.h sources/timer/timer.h] в соответствующее место добавляем определение размера стека задачи таймера:
{{{
#if MSP430
#   define TIMER_STACKSZ 0x400
}}}
В начале файла [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/timer/timer.c sources/timer/timer.c] добавляем объявление номера прерывания таймера:
{{{
#if ELVEES_MC24
#   define TIMER_IRQ 29
#endif
}}}
В функции `main_timer()` в соответствующее место добавляем инициализацию регистров таймера:
{{{
#if ELVEES_MC24
        MC_ITCSR = 0;
        MC_ITSCALE = 0;
        MC_ITPERIOD = t->khz * t->msec_per_tick - 1;
        MC_ITCSR = MC_ITCSR_EN;
#endif
}}}
В цикле ожидания перед вызовом lock_wait() сбрасываем признак прерывания:
{{{
#if ELVEES_MC24
        MC_ITCSR &= ~MC_ITCSR_INT;
#endif
}}}

=== 13. Третий тест: таймер ===
В каталоге uos/examples/msp430-f149 создаём файл test_timer.c:
{{{
#include <runtime/lib.h>
#include "kernel/uos.h"
#include "timer/timer.h"

ARRAY (task, 0x400);
timer_t timer;

void hello (void *arg)
{
        for (;;) {
                debug_printf ("Hello from `%s'! msec = %d\n",
                        arg, timer_milliseconds (&timer));
                lock_wait (&timer.decisec);
        }
}

void uos_init (void)
{
        debug_puts ("\nTesting timer.\n");
        timer_init (&timer, 100, KHZ, 1000);
        task_create (hello, "task", "hello", 1, task, sizeof (task));
}
}}}
В файле Makefile устанавливаем `TESTS = test_timer.sre`.
Запускаем "make". В результате получаем файл, который загружаем в ПЗУ целевой платы. При включении на консоль должна выдаваться строка "Hello from `task'" и счётчик миллисекунд.

=== 14. Драйвер асинхронного порта ===
В начале файла [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/uart/uart.h sources/uart/uart.h] в соответствующее место добавляем определение размера стека задачи асинхронного порта:
{{{
#if MSP430
#   define UART_STACKSZ 0x400
}}}
Аналогично в файле протокола SLIP [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/uart/slip.h sources/uart/slip.h]:
{{{
#if MSP430
#   define SLIP_STACKSZ 0x400
}}}
В начале файлов [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/uart/uart.c sources/uart/uart.c] и [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/uart/slip.c sources/uart/slip.c] добавляем включение файла макросов для MC-24:
{{{
#if ELVEES_MC24
#   include "uart/elvees.h"
#endif
}}}
Создаём файл [http://code.google.com/p/uos-embedded/source/browse/trunk/sources/uart/elvees.h sources/uart/elvees.h] с макросами UART для MC-24:
{{{
#include "kernel/internal.h"

#define RECEIVE_IRQ(p)  4               /* both receive and transmit */

#define enable_receiver(p)              /* already enabled in init() */
#define enable_receive_interrupt(p)     (MC_IER |= MC_IER_ERXRDY | MC_IER_ERLS)
#define disable_receive_interrupt(p)    (MC_IER &= ~(MC_IER_ERXRDY | MC_IER_ERLS))
#define enable_transmit_interrupt(p)    (MC_IER |= MC_IER_ETXRDY)
#define disable_transmit_interrupt(p)   (MC_IER &= ~MC_IER_ETXRDY)

#define transmit_byte(p,c)              (MC_THR = (c))
#define get_received_byte(p)            MC_RBR

#define test_transmitter_enabled(p)     1
#define test_transmitter_empty(p)       (MC_LSR & MC_LSR_TXRDY)
#define test_get_receive_data(p,d)      ((__uart_lsr & MC_LSR_RXRDY) ? \
                                        ((*d) = MC_RBR, 1) : 0)
#define test_frame_error(p)             ((__uart_lsr = MC_LSR) & MC_LSR_FE)
#define test_parity_error(p)            (__uart_lsr & MC_LSR_PE)
#define test_overrun_error(p)           (__uart_lsr & MC_LSR_OE)
#define test_break_error(p)             (__uart_lsr & MC_LSR_BI)
#define clear_frame_error(p)            /* Cleared by reading LSR */
#define clear_parity_error(p)           /* --//-- */
#define clear_overrun_error(p)          /* --//-- */
#define clear_break_error(p)            /* --//-- */

#define setup_baud_rate(p, khz, baud) {                                 \
                unsigned divisor = MC_DL_BAUD (khz * 1000, baud);       \
                MC_LCR = MC_LCR_8BITS | MC_LCR_DLAB;                    \
                MC_DLM = divisor >> 8;                                  \
                MC_DLL = divisor;                                       \
                MC_LCR = MC_LCR_8BITS;                                  \
        }

static unsigned __uart_lsr;
}}}

=== 15. Четвёртый тест: асинхронный порт ===
В каталоге uos/examples/msp430-f149 создаём файл test_uart.c:
{{{
#include <runtime/lib.h>
#include "kernel/uos.h"
#include "uart/uart.h"

ARRAY (task, 0x400);
uart_t uart;

void hello (void *data)
{
        for (;;) {
                puts (&uart, "\nHello, World! ");
                getchar (&uart);
        }
}

void uos_init (void)
{
        debug_puts ("\nTesting UART.\n");
        uart_init (&uart, 0, 90, KHZ, 115200);
        task_create (hello, 0, "hello", 1, task, sizeof (task));
}
}}}
В файле Makefile устанавливаем `TESTS = test_uart.sre`.
Запускаем "make". В результате получаем файл, который загружаем в ПЗУ целевой платы. При включении на консоль должна выдаваться строка "Hello, World".

=== 16. Комплексный тест: пять обедающих философов ===
Проведём комплексную проверку микроядра, драйвера таймера и драйвера асинхронного порта.
В каталоге uos/examples/msp430-f149 создаём файл [http://code.google.com/p/uos-embedded/source/browse/trunk/examples/msp430-f149/philosophers.c examples/msp430-f149/philosophers.c]. В нем помещаем код решения классической задачи [http://en.wikipedia.org/wiki/Dining_philosophers_problem пяти обедающих философов].

В файле Makefile устанавливаем `TESTS = test_philosophers.sre`.
Запускаем "make". В результате получаем файл, который загружаем в ПЗУ целевой платы. При включении на консоли будут отображаться пять философов и изменение их состояния во времени.

Перенос системы uOS на процессор [http://multicore.ru/index.php?id=47 Элвис Мультикор MC-24] можно считать завершённым.
