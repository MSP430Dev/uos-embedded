Конфигурирование загрузки образа
--------------------------------

Конфигурирование загрузки осуществляется в файле target.cfg с помощью установки
 переменных LOADER, CODE_PLACE, DATA_PLACE.

Переменная LOADER устанавливает вариант загрузки образа uOS с прикладной 
программой. Таких вариантов два:
1) напрямую (STANDALONE), т.е. образ содержит необходимый код для своего 
развёртывания. Такой вариант применяется, если образ запускается и работает из 
флеш-памяти или если образ записывается в SDRAM через утилиту mdb.
2) с помощью загрузчика (NVBOOT). В этом случае образ должен быть пристыкован 
к образу загрузчика NVBOOT. NVBOOT запускается всегда из флеш-памяти при 
включении или перезапуске платы и может загрузить исполняемый код uOS как в 
SDRAM, так и в CRAM (в зависимости от настроек).

В режиме STANDALONE образ может быть собран в трёх вариантах:
1) для размещения кода во флеш-памяти необходимо установить переменную 
CODE_PLACE = FLASH. В этом случае образ будет собран так, что исполняемый код 
будет находится во флеш, и процессор будет выбирать команды из неё. Этот 
вариант удобен тем, что при программа хранится в энергонезависимой памяти и 
будет активироваться при подаче питания. Этот вариант также наименее затратный 
с точки зрения используемой памяти для кода, но и самый медленный из-за выборки 
команд из флеш-памяти. Хотя в случае, если размер образа <= 16 Кбайтам, и не 
установлен флаг FLUSH_CACHE_IN_EXCEPTION, то весь образ поместится в кэш-память 
и, соответственно, будет работать максимально быстро. 
Образ может быть записан в плату с помощью команды:
	make load
При этом на инструментальном компьютере должна быть установлена утилита mcprog.
2) для размещения кода в SDRAM необходимо установить переменную 
CODE_PLACE = SDRAM. В этом случае образ соберётся для запуска и работы в SDRAM. 
Он должен быть загружен в SDRAM с помощью JTAG. Для этого удобно использовать 
утилиту mdb. В директории есть примерный файл настроек load-elf.mdb, который 
содержит начальные установки регистров процессора и имя образа, который 
необходимо загрузить в плату. И то, и другое может быть изменено пользователем 
при необходимости. Загрузка и запуск образа осуществляется командой:
	mdb -u -f load-elf.mdb
Преимущество варианта: быстрая запись в плату, существенно более быстрая работа 
платы. Недостаток: образ "теряется" при выключении питания.
Этот вариант хорош для отладки программ.
3) для размещения кода в CRAM (память ОЗУ на кристалле) необходимо установить 
переменную CODE_PLACE = CRAM. Наиболее быстрый вариант, но ограничена память
для кода.

Загрузчик NVBOOT предоставляет возможность совмещения преимуществ различных 
вариантов: хранение образа в энергонезависимой флеш-памяти и более быстрая 
работа за счёт размещения кода в других типах памяти.
В режиме с загрузчиком NVBOOT возможны два варианта:
1) CODE_PLACE = SDRAM. Исполняемый код uOS загружается из флеш-памяти в SDRAM 
при включении платы.
2) CODE_PLACE = СRAM. В этом случае CRAM (ОЗУ на кристалле) делится на две 
части по 64К. Младшая часть используется под исполняемый код, который в неё 
загружает NVBOOT. Старшая часть используется в качестве ОЗУ для данных. Этот 
вариант самый быстрый по производительности, но очевиден его недостаток: только 
128К для кода, если данные также размещаются в CRAM, и 64К для кода, если 
данные размещаются в SDRAM. Из-за этой проблемы даже некоторые тесты 
не получается собрать в варианте, когда код и данные в CRAM. Но при этом 
тесты TCP и UDP показывают практически полную загрузку шины Ethernet.

Вариант CODE_PLACE = FLASH при LOADER = NVBOOT избыточен и не используется.

После получения образа, предназначенного для загрузки с помощью NVBOOT, его 
нужно скопировать в директорию utils/nvboot. Дальнейшие действия описаны в 
файле readme.txt в этой директории.

Размещение изменяемых сегментов данных указывается в переменной DATA_PLACE. 
Существуют всего два варианта: CRAM и SDRAM для размещения данных в CRAM и 
SDRAM, соответственно.


Примечания:
1. После любых изменений в target.cfg настоятельно рекомендуется очистка и 
пересборка проекта командой:
	make clean; make
2. Тесты, использующие сопроцессор плавающей точки (test-fpu, linpack, 
livermore), можно собрать, только если в target.cfg в переменной CFLAGS указан 
флаг включения сопроцессора ARCH_HAVE_FPU, т.е есть строка:
	CFLAGS          += -DARCH_HAVE_FPU
3. Тест livermore требует большого количества памяти для данных, поэтому его 
имеет смысл собирать только в вариантах, когда данные размещены в SDRAM, т.е.
	DATA_PLACE	= SDRAM
4. Модуль uOS, необходимый для теста coremark, не выложен в публичный 
репозиторий в связи с лицензионными ограничениями. Его можно запросить в 
ГУП "НПЦ "Элвис".
5. Тест test-ram можно запускать только в вариантах, в которых не 
задействована память SDRAM: 
  а) код во флеш, данные в CRAM
  б) код в CRAM, данные в CRAM


Тесты производительности стека TCP/IP
-------------------------------------

Тесты test-tcp-client, test-tcp-serv, test-udp-client, test-udp-serv 
демонстрируют производительность приёма-передачи при использовании TCP и UDP. 
Для использования этих тестов на ПК должны быть запущены "ответные части", 
исходные коды которых находятся в папке utils/pc_tests/sockets (их сборка и 
запуск описаны в readme.txt, расположенном в той же папке).
Суть тестов проста - осуществляется односторонняя передача значений счетчика от 
клиента к серверу. Сервер проверяет, что в принимаемых значениях счетчика нет 
"разрыва", т.е. каждое новое значение счетчика больше предыдущего на 1. При 
этом оценивается скорость передачи в клиенте и скорость приема на сервере. 
Значения счетчика передаются не по одному, а "пачками", размер пачки указан в 
макроопределении BUF_SIZE в каждом из тестов. Изменение размера пачки, 
разумеется, влияет на получаемые результаты оценки производительности сети.
Ip-адрес платы указывается в функции uos_init() каждого теста, в строке:
	unsigned char my_ip[] = { 192, 168, 1, 20 };
Ip-адрес сервера, на который необходимо передавать тестовые данные (только для 
test-tcp-client, test-udp-client), указывается в строке:
	unsigned char server_ip [] = { 192, 168, 1, 52 };

У TCP есть параметры, которые можно настроить в target.cfg:
1) TCP_MSS - максимальный размер сегмента TCP, т.е. максимальный сообщения TCP, 
отправляемого за одну посылку.
2) TCP_SND_BUF - размер буфера выдачи, используемого под очередь выдаваемых 
сообщений.
3) TCP_WND - размер буфера приёма, используемого для буферизации принимаемых 
сообщений (окно TCP).

