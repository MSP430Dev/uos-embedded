/*
 * Machine-dependent part of uOS for: Intel i86, DOS, Bruce C Compiler.
 *
 * Copyright (C) 2000-2005 Serge Vakulenko, <vak@cronyx.ru>
 *
 * This file is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.
 *
 * You can redistribute this file and/or modify it under the terms of the GNU
 * General Public License (GPL) as published by the Free Software Foundation;
 * either version 2 of the License, or (at your discretion) any later version.
 * See the accompanying file "COPYING.txt" for more details.
 *
 * As a special exception to the GPL, permission is granted for additional
 * uses of the text contained in this file.  See the accompanying file
 * "COPY-UOS.txt" for details.
 */
#include <runtime/lib.h>
#include <kernel/uos.h>
#include <kernel/internal.h>

#define VECTOR_IRQ0_CHAIN 	0x62
#define VECTOR(irq)		(irq<8 ? irq+8 : irq+0x68)

static unsigned long saved_vector[16];

/*
 * Perform the task switch.
 * Always called with interrupts disabled.
 */
static void
_dos_task_switch (void)
{
	/* We need at least one operator here to force BCC
	 * to generate function prologue _right here_. */
	asm ("export _dos_task_switch");
#asm
_dos_task_switch:
	push    ax
        push    si

	push    bx
	push    cx
	push    dx
	push    es
	push    ds
	push    di
	push    bp
	mov     bp,sp

switch_task:			! Switch to the most priority task
#endasm
	/* Save current task stack. */
	((short*) &task_current->stack_context)[0] = _SP;
	((short*) &task_current->stack_context)[1] = _SS;

	/* Compute new active task. */
	task_policy ();

	/* Switch to the new task. */
	_SP = ((short*) &task_current->stack_context)[0];
	_SS = ((short*) &task_current->stack_context)[1];
#asm
restore_and_ret:
	pop     bp
	pop     di
	pop     ds
	pop     es
	pop     dx
	pop     cx
	pop     bx
	pop     si
	pop     ax
	iret
#endasm
}

/*
 * The common part of the interrupt handler,
 * to minimize the code size.
 */
static void
_dos_intr (void)
{
	/* This must be placed in SI register. */
	register lock_irq_t *h = &lock_irq[0];
#asm
handle_interrupt:
        push    bx
        push    cx
        push    dx
        push    es
        push    ds
        push    di
        push    bp
        mov     bp,sp

        mov     dx,cs		! Compute DS based on CS
        add     dx,#__segoff	! This var generated by the linker
        mov     ds,dx
#endasm

	if (h->handler) {
		/* If the lock is free -- call fast handler. */
		if (h->lock->master) {
			/* Remember pending irq.
			 * Call fast handler later, in lock_release(). */
			h->pending = 1;
			asm ("jmp restore_and_ret");
		}
		if ((h->handler) (h->arg) != 0) {
			/* The fast handler returns 1 when it fully serviced
			 * an interrupt. In this case there is no need to
			 * wake up the interrupt handling task, stopped on
			 * lock_wait. Task switching is not performed. */
			asm ("jmp restore_and_ret");
		}
	}

	/* Signal the interrupt handler, if any. */
	lock_activate (h->lock, 0);
	asm ("jmp switch_task");
}

/*
 * The interrupt handler pattern.
 * Check that BCC places `h' into SI register.
 */
#define HANDLE(n,name,mask)\
	register lock_irq_t *h = &lock_irq[0];\
	asm (name": export "name"\n"\
	"push	ax\n"\
	"push	si\n");\
	mask;				/* disable the irq, avoiding loops */\
	h = &lock_irq[n];\
	asm ("br handle_interrupt")

void intr_0 (), intr_1 (), intr_2 (), intr_3 (), intr_4 (), intr_5 (),
	intr_6 (), intr_7 (), intr_8 (), intr_9 (), intr_10 (), intr_11 (),
	intr_12 (), intr_13 (), intr_14 (), intr_15 ();

static void _intr0  () { HANDLE (0, "_intr_0", asm ("int $62")); }
static void _intr1  () { HANDLE (1, "_intr_1", asm ("mov al,#$20 \n out $20,al \n in al,$21 \n or al,#$02 \n out $21,al")); }
static void _intr2  () { HANDLE (2, "_intr_2", asm ("mov al,#$20 \n out $20,al \n in al,$21 \n or al,#$04 \n out $21,al")); }
static void _intr3  () { HANDLE (3, "_intr_3", asm ("mov al,#$20 \n out $20,al \n in al,$21 \n or al,#$08 \n out $21,al")); }
static void _intr4  () { HANDLE (4, "_intr_4", asm ("mov al,#$20 \n out $20,al \n in al,$21 \n or al,#$10 \n out $21,al")); }
static void _intr5  () { HANDLE (5, "_intr_5", asm ("mov al,#$20 \n out $20,al \n in al,$21 \n or al,#$20 \n out $21,al")); }
static void _intr6  () { HANDLE (6, "_intr_6", asm ("mov al,#$20 \n out $20,al \n in al,$21 \n or al,#$40 \n out $21,al")); }
static void _intr7  () { HANDLE (7, "_intr_7", asm ("mov al,#$20 \n out $20,al \n in al,$21 \n or al,#$80 \n out $21,al")); }
static void _intr8  () { HANDLE (8, "_intr_8", asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$01 \n out $A1,al")); }
static void _intr9  () { HANDLE (9, "_intr_9", asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$02 \n out $A1,al")); }
static void _intr10 () { HANDLE (10,"_intr_10",asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$04 \n out $A1,al")); }
static void _intr11 () { HANDLE (11,"_intr_11",asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$08 \n out $A1,al")); }
static void _intr12 () { HANDLE (12,"_intr_12",asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$10 \n out $A1,al")); }
static void _intr13 () { HANDLE (13,"_intr_13",asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$20 \n out $A1,al")); }
static void _intr14 () { HANDLE (14,"_intr_14",asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$40 \n out $A1,al")); }
static void _intr15 () { HANDLE (15,"_intr_15",asm ("mov al,#$20 \n out $A0,al \n out $20,al \n in al,$A1 \n or al,#$80 \n out $A1,al")); }

static void
setvect (int vecno, unsigned long func)
{
#asm
	mov	bx,sp
	mov	ax,[bx+2]
	mov	dx,[bx+4]
	mov	bx,[bx+6]
	push	ds
	test	bx,bx
	jnz	got_seg
	mov	bx,cs
got_seg:
	mov	ds,bx
	mov	ah,#$25
	int	$21
	pop	ds
#endasm
}

static unsigned long
getvect (int vecno)
{
#asm
	mov	bx,sp
	mov	ax,[bx+2]
	mov	ah,#$35
	push	es
	int	#$21
	mov	dx,es
	mov	ax,bx
	pop	es
#endasm
}

/*
 * Bind the handler to the given hardware interrupt.
 */
void
dos_intr_bind (unsigned char irq)
{
	static void *vector [16] = {
		intr_0,	 intr_1,  intr_2,  intr_3,
		intr_4,  intr_5,  intr_6,  intr_7,
		intr_8,  intr_9,  intr_10, intr_11,
		intr_12, intr_13, intr_14, intr_15,
	};

	saved_vector [irq] = getvect (VECTOR (irq));
	/* cprintf ("bind irq %d, save vector 0x%lx\r\n", irq, saved_vector [irq]); */
	setvect (VECTOR (irq), (unsigned long) vector [irq]);
	if (irq == 0)
		setvect (VECTOR_IRQ0_CHAIN, saved_vector [0]);
}

/*
 * Unbind the interrupt handler.
 */
void
dos_intr_unbind (unsigned char irq)
{
	/* cprintf ("unbind irq %d to 0x%lx\r\n", irq, saved_vector [irq]); */
	if (saved_vector [irq])
		setvect (VECTOR (irq), saved_vector [irq]);
}

/*
 * Allow the given hardware interrupt,
 * unmasking it in the interrupt controller.
 */
void
dos_intr_allow (int irq)
{
	static unsigned char mask [8] = {
		~(1 << 0), ~(1 << 1), ~(1 << 2), ~(1 << 3),
		~(1 << 4), ~(1 << 5), ~(1 << 6), ~(1 << 7),
	};
	int x;

	/* cprintf ("allow irq %d\r\n", irq); */
	if (irq < 8) {
		/* outb (0x21, inb (0x21) & ~(1 << irq)); */
		asm ("in al,$21");
		x = _AX;
		_AX = x & mask [irq];
		asm ("out $21,al");
	} else {
		/* outb (0xa1, inb (0xa1) & ~(1 << (irq & 7))); */
		asm ("in al,$A1");
		x = _AX;
		_AX = x & mask [irq & 7];
		asm ("out $A1,al");
	}
}

/*
 * Halt the system: unbind all interrupts and exit to DOS.
 */
void
dos_halt (void)
{
	int irq;

	/* Restore all interrupt handlers. */
	for (irq=0; irq<16; ++irq)
		dos_intr_unbind (irq);
#asm
	sti
	mov	ax,#$4c00	! DOS exit(0)
	int	$21
#endasm
}

/*
 * Build the initial task's stack frame.
 * Arguments:
 * t	- the task object
 * func	- the task function to call
 * arg	- the function argument
 * sp	- pointer to the (end of) stack space
 */
void
dos_build_stack_frame (task_t *t, void *func, void *arg, unsigned short *stack)
{
	register unsigned short *sp = stack;

	*--sp = arg;			/* task argument */
	*--sp = func;			/* return address */
	*--sp = 0x0200;			/* flags - enable interrupts */
	*--sp = _CS;			/* CS */
	*--sp = func;			/* IP */
	*--sp = 0;			/* ax */
	*--sp = 0;			/* si */
	*--sp = 0;			/* bx */
	*--sp = 0;			/* cx */
	*--sp = 0;			/* dx */
	*--sp = _ES;			/* es */
	*--sp = _DS;			/* ds */
	*--sp = 0;			/* di */
	*--sp = 0;			/* bp */
	((short*) &t->stack_context)[0] = sp;
	((short*) &t->stack_context)[1] = _SS;
}
